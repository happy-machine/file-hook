use notify::{
  event::{CreateKind, Event, EventKind},
  RecommendedWatcher, 
  RecursiveMode, 
  Watcher, 
  Config
};
// use notify::{
//     event::{CreateKind, Event, EventKind},
//     RecursiveMode, Result, Watcher,
// };
use std::{thread, time::Duration};
use std::time;
use std::error::Error;
use std::path::PathBuf;
use std::{env, sync::atomic::Ordering};
use std::{path::Path, sync::Arc};
use std::{sync::atomic::AtomicI32};
use std::collections::HashMap;
use ticktock::Timer;
use clap::Parser;



#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
  #[clap(short, long, action)]
  wait: bool,
  #[clap(short, long, value_parser, default_value_t = 20)]
  seconds: u8,
}

fn post(full_path:String, type_string:String) -> Result<(), Box<dyn Error>> {
    let mut ENDPOINT: String = "".to_string();
    // if args.wait == false {
      ENDPOINT = env::var("ENDPOINT").expect("\nPlease set ENDPOINT environment variable to the endpoint you want to recieve file and folder names.\nTo set, execute \'export ENDPOINT=\"myapi.com/ExamplefileSensorEndpoint\"\'\n");
    let path = PathBuf::from(full_path);
    let target = path.file_name().unwrap();
    let mut map = HashMap::new();
    map.insert("path", target.to_str().unwrap());
    map.insert("type", &type_string);
    let client = reqwest::blocking::Client::new();
    let _res = client.post(ENDPOINT)
        .json(&map)
        .send();
    Ok(())
}

fn main() {
    let args = Args::parse();

    // }
  let FILE_SENSOR_DELAY = std::env::var("FILE_SENSOR_DELAY").unwrap_or("60".to_string());
  let REQUEST_SENSOR_PATH =
  env::var("REQUEST_SENSOR_PATH").unwrap_or("./".to_string());
    if let Err(e) = watch(REQUEST_SENSOR_PATH) {
        println!("error: {:?}", e)
    }
}

fn watch<P: AsRef<Path>>(path: P) -> notify::Result<()> {
    let (tx, rx) = std::sync::mpsc::channel();
    
    // Automatically select the best implementation for your platform.
    // You can also access each implementation directly e.g. INotifyWatcher.
    let mut watcher = RecommendedWatcher::new(tx, Config::default())?;

    // Add a path to be watched. All files and directories at that path and
    // below will be monitored for changes.
    watcher.watch(path.as_ref(), RecursiveMode::Recursive)?;
    let mut request_count = 0;
    let now = time::Instant::now();
let mut heartbeat = Timer::apply(
    |_, count| {
        *count += 1;
        *count
    },
    0,
)
.every(time::Duration::from_millis(500))
.start(now);
    for res in rx {
         request_count += 1;
      match res {
        Ok(event) => {
          match event.kind {
            EventKind::Create(CreateKind::File) => {  
              println!("GOT ONE");
              let request_counter = request_count.clone();
              println!("request_counter{}, request_count{}", request_counter, request_count);
                loop {
                    let now = time::Instant::now();
                    if let Some(n) = heartbeat.update(now) {
                        println!("Heartbeat: {} request_count: {} request_counter: {}", n, request_count, request_counter);
                        if request_count > request_counter {
                                      heartbeat.set_value(0);
                        }
                    }
                }
              // println!("Heartbeat: {}", n);
              // println!("Heartbeat: {}", n);
              // let request_counter = request_count.clone();
              //   std::process::exit(101);
              //   post(event.paths[0].display().to_string(), "file".to_string());

              // println!("new file: {} ", event.paths[0].display().to_string())   
            }
            EventKind::Create(CreateKind::Folder) => {
                  post(event.paths[0].display().to_string(), "folder".to_string());
              println!("new folder: {} ", event.paths[0].display().to_string())   
            }
            _ => { /* something else changed */ }
          }
        }
        Err(e) => {
          panic!("watch error: {:?}", e);
        }
      }
    }

    Ok(())
}